## **《Pandas 索引与切片：超详细学习笔记》**

---

## **1. 概述：Pandas 索引与切片**

Pandas 是数据分析的核心工具之一，其 **DataFrame** 和 **Series** 结构提供了灵活的**索引与切片功能**。这些操作使得我们能够快速访问、修改和筛选数据。

Pandas 提供了多种索引方式，如：
- **基于标签的索引 (`loc[]`)**
- **基于整数位置的索引 (`iloc[]`)**
- **布尔索引**
- **基于查询 (`query()`) 的筛选**
- **多级索引与时间序列索引**

---

## **2. 使用 `loc[]` 基于标签的索引与切片**

- **`loc[]`** 是基于标签的索引，用于按**行名**和**列名**提取数据。
- 支持**单个标签、多标签和切片**访问。

### **2.1 单个标签的访问**
```python
import pandas as pd

data = {'A': [10, 20, 30], 'B': [40, 50, 60]}
df = pd.DataFrame(data, index=['row1', 'row2', 'row3'])

# 获取特定单元格的值
print(df.loc['row1', 'A'])  # 输出：10
```

### **2.2 多标签访问**
```python
# 获取多行、多列的数据
print(df.loc[['row1', 'row2'], ['A', 'B']])
# 输出：
#        A   B
# row1  10  40
# row2  20  50
```

### **2.3 标签切片（包含结束标签）**
```python
print(df.loc['row1':'row2', 'A':'B'])
# 输出：
#        A   B
# row1  10  40
# row2  20  50
```

---

## **3. 使用 `iloc[]` 基于整数位置的索引**

- **`iloc[]`** 是基于整数位置的索引，用于按**行索引和列索引**访问数据。
- **索引从 0 开始**，不包含结束位置。

### **3.1 单个元素访问**
```python
print(df.iloc[0, 1])  # 输出：40
```

### **3.2 多行多列访问**
```python
print(df.iloc[0:2, 0:2])
# 输出：
#        A   B
# row1  10  40
# row2  20  50
```

---

## **4. 使用布尔条件进行索引**

- **布尔索引**根据条件筛选数据，是一种灵活的数据查询方式。

### **4.1 基于单条件的筛选**
```python
print(df[df['A'] > 15])
# 输出：
#        A   B
# row2  20  50
# row3  30  60
```

### **4.2 多条件查询**
```python
print(df[(df['A'] > 15) & (df['B'] < 60)])
# 输出：
#        A   B
# row2  20  50
```

- 使用 **`&`**（与）、**`|`**（或）、**`~`**（非） 进行逻辑运算。

---

## **5. 使用 `query()` 进行类 SQL 查询**

- **`query()`** 方法允许使用类 SQL 语法进行查询，更简洁易读。

### **5.1 示例：`query()` 的使用**
```python
df = pd.DataFrame({'A': [10, 20, 30], 'B': [40, 50, 60], 'C': ['x', 'y', 'z']})
print(df.query('A > 15 and B < 60'))
# 输出：
#        A   B  C
# 1     20  50  y
```

---

## **6. 多级索引的使用**

### **6.1 创建多级索引 DataFrame**
```python
arrays = [['A', 'A', 'B', 'B'], [1, 2, 1, 2]]
index = pd.MultiIndex.from_arrays(arrays, names=['Letter', 'Number'])

df_multi = pd.DataFrame({'Value': [10, 20, 30, 40]}, index=index)
print(df_multi)
# 输出：
#               Value
# Letter Number       
# A      1         10
# A      2         20
# B      1         30
# B      2         40
```

### **6.2 访问多级索引数据**
```python
print(df_multi.loc[('A', 1)])
# 输出：
# Value    10
```

### **6.3 使用 `xs()` 进行跨层索引**
```python
print(df_multi.xs('A', level='Letter'))
# 输出：
#         Value
# Number       
# 1         10
# 2         20
```

---

## **7. 快速访问单个元素：`at[]` 和 `iat[]`**

- **`at[]` 和 `iat[]`** 是专门用于访问单个元素的索引器，**比 `loc[]` 和 `iloc[]` 更快**。

### **7.1 使用 `at[]` 访问**
```python
print(df.at['row1', 'A'])  # 输出：10
```

### **7.2 使用 `iat[]` 访问**
```python
print(df.iat[0, 1])  # 输出：40
```

---

## **8. 时间序列数据的索引与切片**

Pandas 提供了强大的**时间序列处理能力**，支持基于日期的索引与切片。

### **8.1 创建时间序列 DataFrame**
```python
date_range = pd.date_range(start='2023-01-01', periods=5, freq='D')
df_time = pd.DataFrame({'Value': [10, 20, 30, 40, 50]}, index=date_range)
print(df_time)
```

### **8.2 基于日期的切片**
```python
print(df_time['2023-01-02':'2023-01-04'])
# 输出：
#             Value
# 2023-01-02     20
# 2023-01-03     30
# 2023-01-04     40
```

---

## **9. 索引与切片的注意事项**

- **切片返回的是视图**（View），而不是副本（Copy）。对切片数据的修改会影响原数据。
- 如果需要一个独立的数据副本，可以使用 **`copy()`** 方法。

#### **示例：切片与副本的区别**
```python
sliced_data = df.iloc[0:2].copy()
sliced_data['A'] = 100
print(df)  # 原数据不会受影响
```

---

## **10. 实战练习**

1. **创建 DataFrame，使用 `loc` 和 `iloc` 提取数据**。
2. **使用布尔索引筛选出符合条件的行**。
3. **创建多级索引的 DataFrame，并通过 `xs()` 进行切片操作**。
4. **创建时间序列 DataFrame，按日期范围进行切片**。

---

## **11. 总结**

- **`loc[]` 和 `iloc[]`** 是 Pandas 中最常用的索引器，分别基于标签和整数位置进行访问。
- **布尔索引**和 **`query()`** 提供了灵活的数据筛选方式。
- **多级索引**和**时间序列索引**让 Pandas 处理复杂数据集更加方便。
- 使用 **`at[]` 和 `iat[]`** 可以更快速地访问单个元素，提升数据访问性能。

---

这份详细的 Pandas 索引与切片笔记涵盖了所有常见的索引方法、查询技巧和切片操作。通过这些知识，你将能够高效处理和分析各种结构化数据。